#!/usr/bin/env bash
#
# Unicorn Chat
# Prints a message inside a bubble next to (or above) a unicorn ASCII art.
# Usage:
#   ./unicorn_chat.sh [--above] "Your message here"
#   echo "Your message here" | ./unicorn_chat.sh [--above]

###############################################################################
# Constants / Configuration
###############################################################################

REQUIRED_COMMANDS=("tput" "fold" "wc" "head" "printf" "cat" "seq" "command" "read" "echo")

###############################################################################
# Function: check_requirements
# Checks if all required external commands are available.
###############################################################################
check_requirements() {
  local missing=false
  for cmd in "${REQUIRED_COMMANDS[@]}"; do
    if ! command -v "$cmd" &>/dev/null; then
      echo "Error: '$cmd' command is required but not found in PATH."
      missing=true
    fi
  done
  if [ "$missing" = true ]; then
    exit 1
  fi
}

###############################################################################
# Function: usage
# Prints usage information for this script.
###############################################################################
usage() {
  cat <<EOF
Usage: $0 [--above] "message"
       echo "message" | $0 [--above]

Options:
  --above   Force the unicorn to be displayed below the message bubble, 
            even if terminal width is sufficient for side-by-side.

Description:
  Prints a unicorn ASCII art along with a stylized speech bubble containing 
  the provided message. The bubble is displayed side-by-side with the 
  unicorn if the terminal width is large, or forced above if '--above' 
  is specified or if the terminal is too narrow.
EOF
}

###############################################################################
# Function: get_width
# Returns the width of the first line of the input text.
###############################################################################
get_width() {
  echo "$(head -n1 <<<"$@" | wc -c)"
}

###############################################################################
# Function: get_height
# Returns the height of the input text.
###############################################################################
get_height() {
  echo "$@" | wc -l
}

###############################################################################
# Function: unicorn_art_large
# Prints the large unicorn ASCII art (suitable for bigger terminals).
###############################################################################
unicorn_art_large() {
  cat <<'EOF'
                ,.. /      
              ,'   ';      
   ,,.__    _,' /';  .     
  :','  ~~~~    '. '`      
  :' (   )         )::,    
  '. '. .=----=..-~  .;'   
   '  ;'  ::   ':.  '      
     (:   ':    ;)         
      \   '"  ./           
       '"      '"          
EOF
}

###############################################################################
# Function: unicorn_art_small_left
# Prints a smaller unicorn ASCII art, aligned to the left.
###############################################################################
unicorn_art_small_left() {
  cat <<'EOF'
             /   
          ,,/_   
    _     ~/=-"  
   ~ )___~//     
   _//---\|_     
  /        /     
EOF
}

###############################################################################
# Function: unicorn_art_small_right
# Prints a smaller unicorn ASCII art, aligned to the right (unused in
# this script, but kept for completeness).
###############################################################################
unicorn_art_small_right() {
  cat <<'EOF'
       \
       _\,,
      "-=\~     _
         \\~___( ~
        _|/---\\_
        \        \
EOF
}

###############################################################################
# Bubble Rendering Functions
###############################################################################

###############################################################################
# Function: print_border
# Prints the top or bottom border of the message bubble.
# Arguments:
#   $1 - "top" or "bottom"
#   $2 - The string of repeated border characters (e.g., '─' x some length)
###############################################################################
print_border() {
  local border_type="$1"
  local border_str="$2"
  if [ "$border_type" = "top" ]; then
    echo "┌${border_str}┐"
  else
    echo "└${border_str}┘"
  fi
}

###############################################################################
# Function: print_empty_line
# Prints an empty (padding) line within the bubble.
# Arguments:
#   $1 - The width to fill
###############################################################################
print_empty_line() {
  local length="$1"
  printf "│   %-*s   │\n" "$length" ""
}

###############################################################################
# Function: print_message_line
# Prints a single line of the message within the bubble.
# Arguments:
#   $1 - The width of the bubble's content area
#   $2 - The actual line to print
###############################################################################
print_message_line() {
  local length="$1"
  local line="$2"
  printf "│   %-*s   │\n" "$length" "$line"
}

###############################################################################
# Function: message_bubble
# Arguments:
#   $1 - The message to display
#   $2 - Optional offset (indentation) for side-by-side alignment
# Outputs:
#   The entire bubble as multiple lines of text (via echo).
###############################################################################
message_bubble() {
  local message="$1"
  local offset="${2:-0}"
  local terminal_width
  terminal_width=$(tput cols)

  # Calculate wrap width
  local wrap_width=$((terminal_width - 9 - offset))
  [ $wrap_width -lt 1 ] && wrap_width=1

  # Use fold for word wrapping
  local wrapped_message
  wrapped_message=$(echo "$message" | fold -s -w $wrap_width)

  # Find max line length in one pass
  local length=0
  while IFS= read -r wrapped_line; do
    ((${#wrapped_line} > length)) && length=${#wrapped_line}
  done <<<"$wrapped_message"

  # Build border line
  local border_length=$((length + 6))
  local border_chars
  border_chars="$(printf '─%.0s' $(seq 1 "$border_length"))"

  # Compose bubble
  {
    echo "┌${border_chars}┐"
    printf "│   %-*s   │\n" "$length" ""
    while IFS= read -r wm; do
      printf "│   %-*s   │\n" "$length" "$wm"
    done <<<"$wrapped_message"
    printf "│   %-*s   │\n" "$length" ""
    echo "└${border_chars}┘"
  }
}

###############################################################################
# Function: adjust_unicorn_spacing
# Arguments:
#   $1 - The bubble text (already generated string)
#   $2 - The unicorn ASCII art (multi-line)
# Outputs:
#   The combined, side-by-side content.
###############################################################################
adjust_unicorn_spacing() {
  local bubble="$1"
  local unicorn="$2"
  IFS=$'\n' read -rd '' -a bubble_lines <<<"$bubble"
  IFS=$'\n' read -rd '' -a unicorn_lines <<<"$unicorn"

  # Calculate max width of the first line of unicorn
  local first_line="${unicorn_lines[0]}"
  local unicorn_width=${#first_line}
  local spaces
  spaces="$(printf '%*s' "$unicorn_width" '')"

  # Determine bubble vs unicorn line counts
  local bubble_count=${#bubble_lines[@]}
  local unicorn_count=${#unicorn_lines[@]}
  local additional_lines=$((bubble_count - unicorn_count))
  ((additional_lines < 0)) && additional_lines=0
  local half_additional=$((additional_lines / 2))

  # Pad unicorn top/bottom lines
  for _ in $(seq 1 "$half_additional"); do
    unicorn_lines=("$spaces" "${unicorn_lines[@]}" "$spaces")
  done
  unicorn_lines+=("$spaces")

  # Merge line by line
  local max_count=$((bubble_count > unicorn_count ? bubble_count : unicorn_count))
  for ((i = 0; i < max_count; i++)); do
    echo -n "${unicorn_lines[i]:-$spaces}"
    echo "${bubble_lines[i]:-}"
  done
}

###############################################################################
# Function: print_message_with_unicorn
# Determines whether to print the unicorn side-by-side or above the bubble.
# Arguments:
#   $1 - The message to display
#   $2 - Boolean flag "true" if forced above
###############################################################################
print_message_with_unicorn() {
  local message="$1"
  local force_above="$2"

  local terminal_cols
  terminal_cols=$(tput cols)
  local terminal_rows
  terminal_rows=$(tput lines)

  local unicorn_art
  # Decide small or large unicorn
  if [ "$terminal_rows" -gt "$(get_height "$(unicorn_art_large)")" ]; then
    unicorn_art="$(unicorn_art_large)"
  else
    unicorn_art="$(unicorn_art_small_left)"
  fi

  # If forced above or terminal too narrow, print bubble above
  if [ "$force_above" = true ] || [ "$terminal_cols" -lt 60 ]; then
    message_bubble "$message"
    echo "$unicorn_art"
  else
    # For side-by-side
    local unicorn_width
    unicorn_width="$(($(get_width "$unicorn_art") - 2))"
    # Generate the bubble text with offset
    local bubble_text
    bubble_text="$(message_bubble "$message" "$unicorn_width")"

    # Combine side-by-side and print
    adjust_unicorn_spacing "$bubble_text" "$unicorn_art"
  fi
}

###############################################################################
# Main: Parse arguments, handle input, print result.
###############################################################################
main() {
  check_requirements

  local force_above=false
  local input_message=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
    --above)
      force_above=true
      shift
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    *)
      input_message="$1"
      shift
      ;;
    esac
  done

  # If there's data in stdin and no message in arguments
  if [ -p /dev/stdin ] && [ -z "$input_message" ]; then
    input_message="$(cat)"
  fi

  # If still no message, show usage
  if [ -z "$input_message" ]; then
    usage
    exit 1
  fi

  # If ansi2txt is available, convert any ANSI escapes to plain text
  if command -v ansi2txt &>/dev/null; then
    input_message="$(echo "$input_message" | ansi2txt)"
  fi

  print_message_with_unicorn "$input_message" "$force_above"
}

# Run script
main "$@"
