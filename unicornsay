#!/bin/bash

# Function to create a message bubble
message_bubble() {
  local message="$1"
  local offset="${2:-0}"
  local wrapped_message length

  local terminal_width=$(tput cols)
  local wrap_width=$(((terminal_width - 7) - offset))

  message=$(echo "$message" | sed 's/\t/    /g')
  wrapped_message=$(echo "$message" | fold -s -w "$wrap_width" | sed 's/[[:space:]]*$//')
  length=$(echo "$wrapped_message" | awk '{if (length > max) max = length} END {print max}')
  local border_length=$((length + 6))
  local border_top="$(printf '─%.0s' $(seq 1 $border_length))"

  # Print message bubble
  print_border "top" "$border_top"
  print_empty_line "$length"
  echo "$wrapped_message" | while IFS= read -r line; do
    print_message_line "$length" "$line"
  done
  print_empty_line "$length"
  print_border "bottom" "$border_top"
}

# Function to print the unicorn ASCII art
unicorn_art() {
  cat <<'EOF'
                ,.. /        
              ,'   ';        
   ,,.__    _,' /';  .       
  :','  ~~~~    '. '`        
  :' (   )         )::,      
  '. '. .=----=..-~  .;'     
   '  ;'  ::   ':.  '        
     (:   ':    ;)           
      \   '"  ./             
       '"      '"            
EOF
}

unicorn_art_small_right() {
  cat <<'EOF'
       \
       _\,,
      "-=\~     _
         \\~___( ~
        _|/---\\_
        \        \
EOF
}

unicorn_art_small_left() {
  cat <<'EOF'
             /   
          ,,/_   
    _     ~/=-"  
   ~ )___~//     
   _//---\|_     
  /        /     
EOF
}

# Function to print borders for the message bubble
print_border() {
  local type="$1"
  local border_top="$2"
  if [ "$type" = "top" ]; then
    echo "┌$border_top┐"
  else
    echo "└$border_top┘"
  fi
}

# Function to print an empty message line
print_empty_line() {
  local length="$1"
  printf "│   %-*s   │\n" "$length" ""
}

# Function to print a line inside the message bubble
print_message_line() {
  local length="$1"
  local line="$2"
  printf "│   %-*s   │\n" "$length" "$line"
}

# Function to handle printing logic
print_message() {
  local message="$1"
  local tcols=$(tput cols)
  local trows=$(tput lines)
  local unicorn=""
  if [ "$trows" -lt 25 ]; then
    unicorn=$(unicorn_art_small_left)
  else
    unicorn=$(unicorn_art)
  fi

  local unicorn_width=$(head -n 1 <<<"$unicorn" | wc -c)

  if [ "$force_above" = true ] || [ "$tcols" -lt 60 ]; then
    message_bubble "$message"
    echo "$unicorn"
  else
    message=$(message_bubble "$message" $((unicorn_width)))
    adjust_unicorn_spacing "$message" "$unicorn"
  fi
}

# Function to adjust unicorn spacing when printing side by side
adjust_unicorn_spacing() {
  local message="$1"
  local unicorn="$2"
  local unicorn_lines=$(echo "$unicorn" | wc -l)
  local unicorn_width=$(head -n 1 <<<"$unicorn" | wc -c)
  unicorn_width=$((unicorn_width - 1))
  local spaces=$(printf '%*s' $unicorn_width '')

  local line_number=0 new_lines=0
  while IFS= read -r line; do
    line_number=$((line_number + 1))
    if [ $line_number -gt $unicorn_lines ]; then
      new_lines=$((new_lines + 1))
    fi
  done <<<"$message"

  local rounded_lines=$((new_lines / 2))

  if [ $new_lines -gt 0 ]; then
    for _ in $(seq 1 $rounded_lines); do
      unicorn=$(printf "%s\n%s" "$spaces" "$unicorn")
      unicorn=$(printf "%s\n%s" "$unicorn" "$spaces")
    done
  fi
  unicorn=$(printf "%s\n%s" "$unicorn" "$spaces")

  local combined_output=$(paste -d '' <(echo "$unicorn") <(echo "$message"))
  echo "$combined_output"
}

# Parse arguments
force_above=false
input=""
while [[ $# -gt 0 ]]; do
  case "$1" in
  --above)
    force_above=true
    shift
    ;;
  *)
    input="$1"
    shift
    ;;
  esac
done

# Read input from pipe if available
if [ -p /dev/stdin ]; then
  input=$(cat)
elif [ -z "$input" ]; then
  echo "Usage: $0 [--above] \"message\" or echo 'message' | $0 [--above]"
  exit 1
fi

# Convert ANSI escape sequences to plain text
if command -v ansi2txt &>/dev/null; then
  input=$(echo "$input" | ansi2txt)
fi

print_message "$input"
