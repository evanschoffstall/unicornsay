#!/bin/bash

# Function to display the unicorn with a message in a table format
unicornsay() {
  local message="$1"
  local wrapped_message
  local length

  # Get the terminal width
  local terminal_width=$(tput cols)
  local wrap_width=$((terminal_width - 8)) # Adjust for padding

  # Replace tabs with spaces
  message=$(echo "$message" | sed 's/\t/    /g')

  # Wrap text at the terminal width, ensuring consistent spacing
  wrapped_message=$(echo "$message" | fold -s -w "$wrap_width" | sed 's/[[:space:]]*$//')
  length=$(echo "$wrapped_message" | awk '{if (length > max) max = length} END {print max}')
  local border_length=$((length + 6)) # Padding for aesthetics
  local border_top="$(printf '─%.0s' $(seq 1 $border_length))"

  # Print message in table format
  echo "┌$border_top┐"
  printf "│   %-*s   │\n" "$length"
  echo "$wrapped_message" | while IFS= read -r line; do
    printf "│   %-*s   │\n" "$length" "$line"
  done
  printf "│   %-*s   │\n" "$length"
  echo "└$border_top┘"

  # Print unicorn ASCII art
  cat <<'EOF'
               ,.. /
             ,'   ';
  ,,.__    _,' /';  .
 :','  ~~~~    '. '`
 :' (   )         )::,
 '. '. .=----=..-~  .;'
  '  ;'  ::   ':.  '
    (:   ':    ;)
     \   '"  ./
      '"      '"
EOF
}

# Read input from pipe or argument
if [ -p /dev/stdin ]; then
  input=$(cat)
elif [ -n "$1" ]; then
  input="$1"
else
  echo "Usage: $0 \"message\" or echo 'message' | $0"
  exit 1
fi

# Convert ANSI escape sequences to plain text
if command -v ansi2txt &>/dev/null; then
  input=$(echo "$input" | ansi2txt)
fi

unicornsay "$input"
